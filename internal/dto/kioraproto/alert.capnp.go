// Code generated by capnpc-go. DO NOT EDIT.

package kioraproto

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	schemas "capnproto.org/go/capnp/v3/schemas"
)

type Alerts capnp.Struct

// Alerts_TypeID is the unique identifier for the type Alerts.
const Alerts_TypeID = 0xf3c77a394ac60718

func NewAlerts(s *capnp.Segment) (Alerts, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Alerts(st), err
}

func NewRootAlerts(s *capnp.Segment) (Alerts, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Alerts(st), err
}

func ReadRootAlerts(msg *capnp.Message) (Alerts, error) {
	root, err := msg.Root()
	return Alerts(root.Struct()), err
}

func (s Alerts) String() string {
	str, _ := text.Marshal(0xf3c77a394ac60718, capnp.Struct(s))
	return str
}

func (s Alerts) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Alerts) DecodeFromPtr(p capnp.Ptr) Alerts {
	return Alerts(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Alerts) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Alerts) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Alerts) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Alerts) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Alerts) Alerts() (Alert_List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Alert_List(p.List()), err
}

func (s Alerts) HasAlerts() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Alerts) SetAlerts(v Alert_List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewAlerts sets the alerts field to a newly
// allocated Alert_List, preferring placement in s's segment.
func (s Alerts) NewAlerts(n int32) (Alert_List, error) {
	l, err := NewAlert_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Alert_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}

// Alerts_List is a list of Alerts.
type Alerts_List = capnp.StructList[Alerts]

// NewAlerts creates a new list of Alerts.
func NewAlerts_List(s *capnp.Segment, sz int32) (Alerts_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Alerts](l), err
}

// Alerts_Future is a wrapper for a Alerts promised by a client call.
type Alerts_Future struct{ *capnp.Future }

func (f Alerts_Future) Struct() (Alerts, error) {
	p, err := f.Future.Ptr()
	return Alerts(p.Struct()), err
}

type Alert capnp.Struct

// Alert_TypeID is the unique identifier for the type Alert.
const Alert_TypeID = 0xc5154448f10c0d22

func NewAlert(s *capnp.Segment) (Alert, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 2})
	return Alert(st), err
}

func NewRootAlert(s *capnp.Segment) (Alert, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 2})
	return Alert(st), err
}

func ReadRootAlert(msg *capnp.Message) (Alert, error) {
	root, err := msg.Root()
	return Alert(root.Struct()), err
}

func (s Alert) String() string {
	str, _ := text.Marshal(0xc5154448f10c0d22, capnp.Struct(s))
	return str
}

func (s Alert) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Alert) DecodeFromPtr(p capnp.Ptr) Alert {
	return Alert(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Alert) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Alert) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Alert) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Alert) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Alert) Labels() (Map, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Map(p.Struct()), err
}

func (s Alert) HasLabels() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Alert) SetLabels(v Map) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewLabels sets the labels field to a newly
// allocated Map struct, preferring placement in s's segment.
func (s Alert) NewLabels() (Map, error) {
	ss, err := NewMap(capnp.Struct(s).Segment())
	if err != nil {
		return Map{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Alert) Annotations() (Map, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return Map(p.Struct()), err
}

func (s Alert) HasAnnotations() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Alert) SetAnnotations(v Map) error {
	return capnp.Struct(s).SetPtr(1, capnp.Struct(v).ToPtr())
}

// NewAnnotations sets the annotations field to a newly
// allocated Map struct, preferring placement in s's segment.
func (s Alert) NewAnnotations() (Map, error) {
	ss, err := NewMap(capnp.Struct(s).Segment())
	if err != nil {
		return Map{}, err
	}
	err = capnp.Struct(s).SetPtr(1, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Alert) Status() AlertStatus {
	return AlertStatus(capnp.Struct(s).Uint16(0))
}

func (s Alert) SetStatus(v AlertStatus) {
	capnp.Struct(s).SetUint16(0, uint16(v))
}

func (s Alert) StartTime() int64 {
	return int64(capnp.Struct(s).Uint64(8))
}

func (s Alert) SetStartTime(v int64) {
	capnp.Struct(s).SetUint64(8, uint64(v))
}

func (s Alert) EndTime() int64 {
	return int64(capnp.Struct(s).Uint64(16))
}

func (s Alert) SetEndTime(v int64) {
	capnp.Struct(s).SetUint64(16, uint64(v))
}

// Alert_List is a list of Alert.
type Alert_List = capnp.StructList[Alert]

// NewAlert creates a new list of Alert.
func NewAlert_List(s *capnp.Segment, sz int32) (Alert_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 24, PointerCount: 2}, sz)
	return capnp.StructList[Alert](l), err
}

// Alert_Future is a wrapper for a Alert promised by a client call.
type Alert_Future struct{ *capnp.Future }

func (f Alert_Future) Struct() (Alert, error) {
	p, err := f.Future.Ptr()
	return Alert(p.Struct()), err
}
func (p Alert_Future) Labels() Map_Future {
	return Map_Future{Future: p.Future.Field(0, nil)}
}
func (p Alert_Future) Annotations() Map_Future {
	return Map_Future{Future: p.Future.Field(1, nil)}
}

type AlertStatus uint16

// AlertStatus_TypeID is the unique identifier for the type AlertStatus.
const AlertStatus_TypeID = 0x8b4db636305301a6

// Values of AlertStatus.
const (
	AlertStatus_firing   AlertStatus = 0
	AlertStatus_resolved AlertStatus = 1
)

// String returns the enum's constant name.
func (c AlertStatus) String() string {
	switch c {
	case AlertStatus_firing:
		return "firing"
	case AlertStatus_resolved:
		return "resolved"

	default:
		return ""
	}
}

// AlertStatusFromString returns the enum value with a name,
// or the zero value if there's no such value.
func AlertStatusFromString(c string) AlertStatus {
	switch c {
	case "firing":
		return AlertStatus_firing
	case "resolved":
		return AlertStatus_resolved

	default:
		return 0
	}
}

type AlertStatus_List = capnp.EnumList[AlertStatus]

func NewAlertStatus_List(s *capnp.Segment, sz int32) (AlertStatus_List, error) {
	return capnp.NewEnumList[AlertStatus](s, sz)
}

type Map capnp.Struct

// Map_TypeID is the unique identifier for the type Map.
const Map_TypeID = 0xd15e0ab5486a2241

func NewMap(s *capnp.Segment) (Map, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Map(st), err
}

func NewRootMap(s *capnp.Segment) (Map, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Map(st), err
}

func ReadRootMap(msg *capnp.Message) (Map, error) {
	root, err := msg.Root()
	return Map(root.Struct()), err
}

func (s Map) String() string {
	str, _ := text.Marshal(0xd15e0ab5486a2241, capnp.Struct(s))
	return str
}

func (s Map) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Map) DecodeFromPtr(p capnp.Ptr) Map {
	return Map(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Map) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Map) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Map) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Map) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Map) Entries() (Map_Entry_List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Map_Entry_List(p.List()), err
}

func (s Map) HasEntries() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Map) SetEntries(v Map_Entry_List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewEntries sets the entries field to a newly
// allocated Map_Entry_List, preferring placement in s's segment.
func (s Map) NewEntries(n int32) (Map_Entry_List, error) {
	l, err := NewMap_Entry_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Map_Entry_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}

// Map_List is a list of Map.
type Map_List = capnp.StructList[Map]

// NewMap creates a new list of Map.
func NewMap_List(s *capnp.Segment, sz int32) (Map_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Map](l), err
}

// Map_Future is a wrapper for a Map promised by a client call.
type Map_Future struct{ *capnp.Future }

func (f Map_Future) Struct() (Map, error) {
	p, err := f.Future.Ptr()
	return Map(p.Struct()), err
}

type Map_Entry capnp.Struct

// Map_Entry_TypeID is the unique identifier for the type Map_Entry.
const Map_Entry_TypeID = 0xe450011b48235af4

func NewMap_Entry(s *capnp.Segment) (Map_Entry, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Map_Entry(st), err
}

func NewRootMap_Entry(s *capnp.Segment) (Map_Entry, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Map_Entry(st), err
}

func ReadRootMap_Entry(msg *capnp.Message) (Map_Entry, error) {
	root, err := msg.Root()
	return Map_Entry(root.Struct()), err
}

func (s Map_Entry) String() string {
	str, _ := text.Marshal(0xe450011b48235af4, capnp.Struct(s))
	return str
}

func (s Map_Entry) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Map_Entry) DecodeFromPtr(p capnp.Ptr) Map_Entry {
	return Map_Entry(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Map_Entry) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Map_Entry) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Map_Entry) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Map_Entry) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Map_Entry) Key() (capnp.Ptr, error) {
	return capnp.Struct(s).Ptr(0)
}

func (s Map_Entry) HasKey() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Map_Entry) SetKey(v capnp.Ptr) error {
	return capnp.Struct(s).SetPtr(0, v)
}
func (s Map_Entry) Value() (capnp.Ptr, error) {
	return capnp.Struct(s).Ptr(1)
}

func (s Map_Entry) HasValue() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Map_Entry) SetValue(v capnp.Ptr) error {
	return capnp.Struct(s).SetPtr(1, v)
}

// Map_Entry_List is a list of Map_Entry.
type Map_Entry_List = capnp.StructList[Map_Entry]

// NewMap_Entry creates a new list of Map_Entry.
func NewMap_Entry_List(s *capnp.Segment, sz int32) (Map_Entry_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[Map_Entry](l), err
}

// Map_Entry_Future is a wrapper for a Map_Entry promised by a client call.
type Map_Entry_Future struct{ *capnp.Future }

func (f Map_Entry_Future) Struct() (Map_Entry, error) {
	p, err := f.Future.Ptr()
	return Map_Entry(p.Struct()), err
}
func (p Map_Entry_Future) Key() *capnp.Future {
	return p.Future.Field(0, nil)
}
func (p Map_Entry_Future) Value() *capnp.Future {
	return p.Future.Field(1, nil)
}

const schema_bca48e54c9238692 = "x\xda\xacSOk\x14K\x1c\xac\xea\x9ey\x93\xf7\xd8" +
	"\xbcl\xa7W\xa2\x18\xd9\xb0\x89\x18\xc1\x84$\x8a\x9a\xbd" +
	"l\x12\x14B4\x90v\x82\x07\x0f\xc2\xc4\x8c\xb2\xba\x99" +
	"\x84\x9dIt\x85 \x0a\x0a\"\x08\x06<\xe8Y\xfc\x00" +
	"\x82\x9e<\x09\xfe\x09x\xf1;\xf8\x05\x82z\xf04\xd2" +
	"\xab\xeeNX\x8f\x1ef\xa0k\xaa\xab\xba\xaa\x7f3v" +
	"\x96S\xcexwQB\x98!\xf7\x9f\xf49\xfd\xb1\xe3" +
	"\xaf\xe6\x1f@\xe5D\xbauop{\xf1\xe1\xb3\xd7\x00" +
	"\xf5:\xdf\xe8Mz\x80n\xf0\x04\x98\x96\xbas;\xb3" +
	"\xa7\xf6\xbc\x85\xc9Q\xb6\x99\xae\xb0\x94\xdb\xdc\xd2\xf7-" +
	"\xf9\xe8]\x16\x09\xa6\xd3\xa5\xab\xb3/\xff\xbb\xf8\x09*" +
	"\xc7\x0c\x99^\x9ezD\xde\xd1\xe3\xb2\x0f\xd0\x93\xb2\x02" +
	"\xe8\xc7\xb2/\xfdzapv?\x17>C\xe53\x9b" +
	"]a\xf9\x8f\xe4\x0b\xfdDzM\xe6u0\xdd\xeb\xbd" +
	"\x9b\x9b\xbc\xf9\xfeK\x876\xa0w\xe4S\xfd\xbd\xc9\xfd" +
	"&+\x18I\x83ZXOF/\x05b-Z+O" +
	"\xdb\x85\x9f\x04\xc9z\x8c\x05\xd2tQ\x00J\x95\x01R" +
	"\xfd;\x07T.W\xeb\xd5\xe8JZ\x0f\xe3\xd5\xdaF" +
	"\xb8\x0c\xa0\xa5\xc0\xdf\x0aL\xec\xde\x82t\x00\x87\x80\xda" +
	",\x03\xe6\x86\xa4\xf9(\xa8\xc8\x02-\xb8\xbd\x04\x98\x0f" +
	"\x92~?\x05)\x0a\xd6I\xefc\x19\xf0\x0b\x94\xf4\x07" +
	"(\xa8$\x0b\x94\x80>\xc0s\x80\xdfo\xf1a\x8b;" +
	"\xa2@\x07\xd0\x079\x03\xf8\x03\x16?B\xc1J-X" +
	"\x0ak1\xf3\xed\x82\x80)*\x16\x8d#\x98\x05\x15\x0f" +
	"\x99.\xd2F\x94\xf6\x9d\x97d\x0e\xa2\xf9\xe4\xc14\x88" +
	"\xa2\xd5$H\xaa\xf0V\xa3\xbf\xa0W\x89\x9b\x9d\xb2\xa7" +
	"=M {\xc04N\x82z\xb2X]\x01C\xba\x10" +
	"t\xc1[a\xb4\xbcX]i\xadw\x17<\x1f\xac\xc1" +
	"8df 8Q<\x1d%\xf5\x86qZ\x95w\xcf" +
	"\x00\xf6(\xe6\xa4\xb0zI\xbd\x1a\xc6\xfc\x1f\\\x90d" +
	"\xbe\xbd\xf5\x8fi\xec\xf5X\xeet\x17\x95[R\xee\x84" +
	"w&l\x14\xcf\x07\xb5\xf5\xb0\xe3(\xa3?\x9d\x9b\xb3" +
	"\xd22?\\\x02\xcc\x90\xa4\x19\xcb\xdc\xf7\xc8\x04`\x86" +
	"%\xcd1A\xefZ\xd8`/w5\xc8^\xb0\xb8a" +
	"M\xd8\xebv~\xea\x9c2\x99\xc4\xd66\x93\xb9\xfc+" +
	"\xf3\x90`\xa5I\xcfDn\xfd\x9c\xa0\x05\x7f\x04\x00\x00" +
	"\xff\xff\xad\xf5\xda@"

func init() {
	schemas.Register(schema_bca48e54c9238692,
		0x8b4db636305301a6,
		0xc5154448f10c0d22,
		0xd15e0ab5486a2241,
		0xe450011b48235af4,
		0xf3c77a394ac60718)
}
