// Code generated by capnpc-go. DO NOT EDIT.

package kioraproto

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	schemas "capnproto.org/go/capnp/v3/schemas"
)

type Alert capnp.Struct

// Alert_TypeID is the unique identifier for the type Alert.
const Alert_TypeID = 0xc5154448f10c0d22

func NewAlert(s *capnp.Segment) (Alert, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 2})
	return Alert(st), err
}

func NewRootAlert(s *capnp.Segment) (Alert, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 2})
	return Alert(st), err
}

func ReadRootAlert(msg *capnp.Message) (Alert, error) {
	root, err := msg.Root()
	return Alert(root.Struct()), err
}

func (s Alert) String() string {
	str, _ := text.Marshal(0xc5154448f10c0d22, capnp.Struct(s))
	return str
}

func (s Alert) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Alert) DecodeFromPtr(p capnp.Ptr) Alert {
	return Alert(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Alert) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Alert) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Alert) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Alert) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Alert) Labels() (Map, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Map(p.Struct()), err
}

func (s Alert) HasLabels() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Alert) SetLabels(v Map) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewLabels sets the labels field to a newly
// allocated Map struct, preferring placement in s's segment.
func (s Alert) NewLabels() (Map, error) {
	ss, err := NewMap(capnp.Struct(s).Segment())
	if err != nil {
		return Map{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Alert) Annotations() (Map, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return Map(p.Struct()), err
}

func (s Alert) HasAnnotations() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Alert) SetAnnotations(v Map) error {
	return capnp.Struct(s).SetPtr(1, capnp.Struct(v).ToPtr())
}

// NewAnnotations sets the annotations field to a newly
// allocated Map struct, preferring placement in s's segment.
func (s Alert) NewAnnotations() (Map, error) {
	ss, err := NewMap(capnp.Struct(s).Segment())
	if err != nil {
		return Map{}, err
	}
	err = capnp.Struct(s).SetPtr(1, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Alert) Status() AlertStatus {
	return AlertStatus(capnp.Struct(s).Uint16(0))
}

func (s Alert) SetStatus(v AlertStatus) {
	capnp.Struct(s).SetUint16(0, uint16(v))
}

func (s Alert) StartTime() int64 {
	return int64(capnp.Struct(s).Uint64(8))
}

func (s Alert) SetStartTime(v int64) {
	capnp.Struct(s).SetUint64(8, uint64(v))
}

func (s Alert) EndTime() int64 {
	return int64(capnp.Struct(s).Uint64(16))
}

func (s Alert) SetEndTime(v int64) {
	capnp.Struct(s).SetUint64(16, uint64(v))
}

// Alert_List is a list of Alert.
type Alert_List = capnp.StructList[Alert]

// NewAlert creates a new list of Alert.
func NewAlert_List(s *capnp.Segment, sz int32) (Alert_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 24, PointerCount: 2}, sz)
	return capnp.StructList[Alert](l), err
}

// Alert_Future is a wrapper for a Alert promised by a client call.
type Alert_Future struct{ *capnp.Future }

func (f Alert_Future) Struct() (Alert, error) {
	p, err := f.Future.Ptr()
	return Alert(p.Struct()), err
}
func (p Alert_Future) Labels() Map_Future {
	return Map_Future{Future: p.Future.Field(0, nil)}
}
func (p Alert_Future) Annotations() Map_Future {
	return Map_Future{Future: p.Future.Field(1, nil)}
}

type AlertStatus uint16

// AlertStatus_TypeID is the unique identifier for the type AlertStatus.
const AlertStatus_TypeID = 0x8b4db636305301a6

// Values of AlertStatus.
const (
	AlertStatus_firing   AlertStatus = 0
	AlertStatus_resolved AlertStatus = 1
)

// String returns the enum's constant name.
func (c AlertStatus) String() string {
	switch c {
	case AlertStatus_firing:
		return "firing"
	case AlertStatus_resolved:
		return "resolved"

	default:
		return ""
	}
}

// AlertStatusFromString returns the enum value with a name,
// or the zero value if there's no such value.
func AlertStatusFromString(c string) AlertStatus {
	switch c {
	case "firing":
		return AlertStatus_firing
	case "resolved":
		return AlertStatus_resolved

	default:
		return 0
	}
}

type AlertStatus_List = capnp.EnumList[AlertStatus]

func NewAlertStatus_List(s *capnp.Segment, sz int32) (AlertStatus_List, error) {
	return capnp.NewEnumList[AlertStatus](s, sz)
}

type Map capnp.Struct

// Map_TypeID is the unique identifier for the type Map.
const Map_TypeID = 0xd15e0ab5486a2241

func NewMap(s *capnp.Segment) (Map, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Map(st), err
}

func NewRootMap(s *capnp.Segment) (Map, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Map(st), err
}

func ReadRootMap(msg *capnp.Message) (Map, error) {
	root, err := msg.Root()
	return Map(root.Struct()), err
}

func (s Map) String() string {
	str, _ := text.Marshal(0xd15e0ab5486a2241, capnp.Struct(s))
	return str
}

func (s Map) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Map) DecodeFromPtr(p capnp.Ptr) Map {
	return Map(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Map) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Map) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Map) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Map) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Map) Entries() (Map_Entry_List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Map_Entry_List(p.List()), err
}

func (s Map) HasEntries() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Map) SetEntries(v Map_Entry_List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewEntries sets the entries field to a newly
// allocated Map_Entry_List, preferring placement in s's segment.
func (s Map) NewEntries(n int32) (Map_Entry_List, error) {
	l, err := NewMap_Entry_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Map_Entry_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}

// Map_List is a list of Map.
type Map_List = capnp.StructList[Map]

// NewMap creates a new list of Map.
func NewMap_List(s *capnp.Segment, sz int32) (Map_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Map](l), err
}

// Map_Future is a wrapper for a Map promised by a client call.
type Map_Future struct{ *capnp.Future }

func (f Map_Future) Struct() (Map, error) {
	p, err := f.Future.Ptr()
	return Map(p.Struct()), err
}

type Map_Entry capnp.Struct

// Map_Entry_TypeID is the unique identifier for the type Map_Entry.
const Map_Entry_TypeID = 0xe450011b48235af4

func NewMap_Entry(s *capnp.Segment) (Map_Entry, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Map_Entry(st), err
}

func NewRootMap_Entry(s *capnp.Segment) (Map_Entry, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Map_Entry(st), err
}

func ReadRootMap_Entry(msg *capnp.Message) (Map_Entry, error) {
	root, err := msg.Root()
	return Map_Entry(root.Struct()), err
}

func (s Map_Entry) String() string {
	str, _ := text.Marshal(0xe450011b48235af4, capnp.Struct(s))
	return str
}

func (s Map_Entry) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Map_Entry) DecodeFromPtr(p capnp.Ptr) Map_Entry {
	return Map_Entry(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Map_Entry) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Map_Entry) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Map_Entry) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Map_Entry) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Map_Entry) Key() (capnp.Ptr, error) {
	return capnp.Struct(s).Ptr(0)
}

func (s Map_Entry) HasKey() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Map_Entry) SetKey(v capnp.Ptr) error {
	return capnp.Struct(s).SetPtr(0, v)
}
func (s Map_Entry) Value() (capnp.Ptr, error) {
	return capnp.Struct(s).Ptr(1)
}

func (s Map_Entry) HasValue() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Map_Entry) SetValue(v capnp.Ptr) error {
	return capnp.Struct(s).SetPtr(1, v)
}

// Map_Entry_List is a list of Map_Entry.
type Map_Entry_List = capnp.StructList[Map_Entry]

// NewMap_Entry creates a new list of Map_Entry.
func NewMap_Entry_List(s *capnp.Segment, sz int32) (Map_Entry_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[Map_Entry](l), err
}

// Map_Entry_Future is a wrapper for a Map_Entry promised by a client call.
type Map_Entry_Future struct{ *capnp.Future }

func (f Map_Entry_Future) Struct() (Map_Entry, error) {
	p, err := f.Future.Ptr()
	return Map_Entry(p.Struct()), err
}
func (p Map_Entry_Future) Key() *capnp.Future {
	return p.Future.Field(0, nil)
}
func (p Map_Entry_Future) Value() *capnp.Future {
	return p.Future.Field(1, nil)
}

const schema_bca48e54c9238692 = "x\xda\xacR\xc1j\xd4\\\x18=\xe7\xde\xe4O\x7f\x99" +
	"\xb1\xb9\xbd\x91\"V\xa6L\x15[\xb0\xa5VQ\x99\xcd" +
	"\xb4E\xa1*\x85^S\x05\x05\x85\xd4F\x89N3C" +
	"\x92Vg!\x82\x0b7\x82\x8b>\x83\xf8\x00\x82\xae\\" +
	"\x09\xa2\x057\xbe\x83/ \xb8\x8f\xdc\x11g\xa6\xd4\xa5" +
	"\x8b\x04\xee\xb9\xe7;\xe7~\xe7\xfb\xe6g\xb8\xe8\x9c\xa9" +
	"~\x16\x10f\xd2\xfd\xaf|\xc3p\xfe\xfc\xfb\xd5\x97P" +
	"\x15Q\xee\xbe\x98\xda[\x7f\xf5\xfa\x03@}\x85\x1f\xb5" +
	"\xa1\x07\xe8U^\x00\xcbz\xb5\xf2c\xe5\xd2\x91O0" +
	"\x15\xca\x01\xd3\x15\x96r\x83\xbb\xfa\x8e%\x9f\xbd\xc5\x1a" +
	"\xc1r\xa9\xfep\xe5\xdd\xa1\xbb\xdf\xa0*\x1c\"\xd3\xf3" +
	"\xa9)\x9fkW\x8e\x03\xba*\x9b\x80N\xe4x\xf9\xf3" +
	"\xf6\xd4\xca1\xae}\x87\xf2\x87\x8a]a\xf9\xb1|\xab" +
	"\xb7\xa4\xd7c>\xc6l\x19\xb5\xe2\xac\x98\xbb\x17\x89N" +
	"\xdai,\xd9CXD\xc5v\x8e5\xd2\x8cP\x00J" +
	"5\x00R\xfd\x7f\x15h\xdeO\xb2$}Pfq\xde" +
	"n\xed\xc4\x9b\x00\xfa\x0a\xfc\xa3\xc0\xc2\xd6\x06\xd2\x01\x1c" +
	"\x02\xeai\x030O$\xcdWAE\x06\xb4\xe0\xde\x06" +
	"`\xbeH\x86\x13\x14\xa4\x08\xac\x93>\xca\x06\x10\x06\x94" +
	"\x0c')\xa8$\x03J@\x1f\xe7u \x9c\xb0\xf8\xb4" +
	"\xc5\x1d\x11\xd0\x01\xf4I.\x03\xe1\xa4\xc5OS\xb0\xd9" +
	"\x8a6\xe2VN\x7f\xd04\xb0H\xc5\x9aq\x04\x87A" +
	"\xc5Sf\x84\xb4-J\xfb\xf7%Y\x81\xe8}>X" +
	"Fi\xda.\xa2\"\x81\xd7N\xff\x81^3\xefe\xca" +
	"\xd1\xc1\x86\x80\x1c\x05\xcb\xbc\x88\xb2b=\xd9\x02c\xba" +
	"\x10t\xc1gq\xba\xb9\x9el\xf5\xcf\xfb\x03^\x8d:" +
	"0\x0e94d.\xd4.\xa7E\xd65N?\xf2\xea" +
	"2`\x9fb.\x0a\xabWdI\x9c\xf30\xb8&I" +
	"\x7fP\xfa\xd7n\xecx,wi\x84\xca\xad+w\xc1" +
	"\xbb\x16wk7\xa3\xd6v|\xe0)s\xbf\x9d{\xbb" +
	"\xd27\x9f\xa9\x03\xe6\x84\xa4\x99\x1f\x9a\xf7\xec\x02`\xa6" +
	"%\xcd9A\xefQ\xdc\xe5\x18\xf7%\xc81\xb0\xb6c" +
	"M8\xe6\x1e\xbc\xfa\x15\x00\x00\xff\xffR%\xb9\xb6"

func init() {
	schemas.Register(schema_bca48e54c9238692,
		0x8b4db636305301a6,
		0xc5154448f10c0d22,
		0xd15e0ab5486a2241,
		0xe450011b48235af4)
}
